<!DOCTYPE html>
<html lang="te">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>శ్రీమద్భగవద్గీత</title>

    <meta name="theme-color" content="#4f46e5"/>
    <link rel="apple-touch-icon" href="/Gita/icons/icon-192x192.png">
    <link rel="manifest" href="/Gita/manifest.json">

    <script src="https://cdn.tailwindcss.com"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Mandali&family=Roboto:wght@400;700&display=swap" rel="stylesheet">

    <script src="https://unpkg.com/@phosphor-icons/web"></script>

    <style>
        body {
            font-family: 'Mandali', sans-serif; /* Apply Mandali for main text */
            background-color: #eef2ff; /* Lighter blue fallback background */
            color: #374151; /* Darker gray text */
            line-height: 1.6;
            min-height: 100vh; /* Ensure body takes at least full viewport height */
            display: flex;
            flex-direction: column;
            /* Divine Background for Main Content - Path updated for /Gita/ */
            /* Ensure you have this image or replace with a placeholder/color */
            background-image: url('/Gita/images/divine-background.jpeg');
            background-size: cover;
            background-position: center;
            background-attachment: fixed; /* Keep background fixed while scrolling */
            overflow-x: hidden; /* Prevent horizontal scrollbar when menu is open */
        }

        /* Apply Roboto to headings and UI elements */
        h1, h2, h3, button, select, input, .font-roboto {
            font-family: 'Roboto', sans-serif;
        }

        /* Overlay for background image to improve text readability */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.7); /* Semi-transparent white overlay - Keep this for overall readability */
            z-index: -1; /* Place behind content */
        }

        .splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #6b46c1; /* Purple fallback */
             /* Classic Bhagavad Gita Image for Splash Screen - Path updated for /Gita/ */
             /* Ensure you have this image or replace with a placeholder/color */
            background-image: url('/Gita/images/splash-image.jpeg');
            background-size: cover;
            background-position: center;
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 2.5rem; /* Slightly larger font */
            z-index: 100;
            transition: opacity 0.8s ease-in-out; /* Smoother transition */
            text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.6); /* More prominent shadow */
        }
        .splash-screen h1 {
            font-size: 3rem; /* Larger title on splash */
            margin-bottom: 0.5rem;
        }
        .splash-screen p {
             font-size: 1.5rem;
        }

        .splash-screen.hidden {
            opacity: 0;
            pointer-events: none; /* Disable interaction when hidden */
        }

        .main-content {
            opacity: 0; /* Initially hidden */
            transition: opacity 0.8s ease-in-out; /* Smoother transition */
            flex-grow: 1; /* Allow main content to take available space */
            /* Reduced top padding for better space utilization */
            padding-top: 1rem; /* Adjusted from p-4/p-8 */
            padding-left: 1rem; /* Keep horizontal padding */
            padding-right: 1rem; /* Keep horizontal padding */
            padding-bottom: 1rem; /* Keep bottom padding */
        }

        /* Adjust padding for larger screens */
        @media (min-width: 768px) { /* md breakpoint */
             .main-content {
                 padding-top: 2rem; /* Restore larger top padding on larger screens */
                 padding-left: 2rem;
                 padding-right: 2rem;
                 padding-bottom: 2rem;
             }
        }


        .main-content.visible {
            opacity: 1; /* Becomes visible */
        }

        /* Styling for the main app heading - Enhanced with Gradient */
        #appHeading {
            font-size: 2.5rem; /* Adjusted size */
            font-weight: bold;
            text-align: center;
            margin-bottom: 1.5rem; /* Reduced margin */
            font-family: 'Roboto', sans-serif;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2); /* Subtle shadow */
            /* Peacock Color Gradient */
            background: linear-gradient(to right, #008080, #4682b4, #008080); /* Teal, Steel Blue, Teal */
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            color: transparent; /* Fallback for browsers that don't support text clipping */
        }


        /* Styling for Sanskrit Verse Text */
        .sanskrit-verse-text {
            color: #059669; /* Green color for Sanskrit verse */
            font-size: 1.3rem; /* Adjusted: Smaller font */
            font-weight: bold;
            line-height: 1.8; /* Improved line spacing */
            white-space: pre-wrap; /* Preserve whitespace and allow wrapping */
            text-align: center; /* Center Sanskrit verse */
            padding: 0 0.5rem; /* Add horizontal padding inside tile */
        }

         /* Styling for the Sanskrit Verse Tile */
         #sanskritVerseTile {
            /* Vibrant and Divine Styling */
            background: linear-gradient(to bottom right, #fffbeb, #fef3c7); /* Light gold/yellow gradient */
            border: 1px solid #fcd34d; /* Gold border */
            border-radius: 0.75rem; /* Rounded corners */
            margin-top: 1rem; /* Space above the tile */
            margin-bottom: 1rem; /* Space below the tile */
            padding: 1.5rem; /* Increased padding for a more substantial feel */
            text-align: center; /* Center the tile content */
            display: flex; /* Use flexbox to arrange items vertically */
            flex-direction: column;
            align-items: center; /* Center items horizontally within the tile */
            box-shadow: 0 6px 12px rgba(252, 211, 77, 0.3); /* Subtle gold shadow */
            position: relative; /* Needed for absolute positioning of audio icon */
         }

         /* Styling for the Chapter/Verse info inside the Sanskrit Tile */
         .sanskrit-tile-info {
            font-size: 1rem; /* Slightly larger font */
            color: #92400e; /* Darker orange/brown color */
            margin-bottom: 0.8rem; /* Increased space below info */
            text-align: center; /* Center the info */
            font-family: 'Roboto', sans-serif; /* Use Roboto for info */
            font-weight: bold; /* Make info bold */
         }


        /* Styling for Polished Telugu Verse (Shlokam) */
        .polished-telugu-verse-text {
            color: #4f46e5; /* Indigo color - blending with primary button color */
            font-size: 1.4rem; /* Slightly larger */
            line-height: 1.7;
            font-style: normal; /* Ensure not italic */
            font-weight: bold; /* Make it bold */
        }

        /* Styling for Telugu Bhavartham (Polished Meaning) */
        .telugu-bhavartham-text {
            color: #d97706; /* Orange color for meaning */
            font-size: 1.3rem; /* Slightly larger meaning font */
            line-height: 1.7;
        }

        /* Styling for Sandesham (Description) */
        .sandesham-text {
            color: #1d4ed8; /* Blue color for description */
            font-size: 1.1rem; /* Slightly larger description font */
            font-style: italic;
            line-height: 1.6;
        }

        /* Styling for the main verse info heading - REMOVED */


        /* Styling for labels */
        .verse-label {
            font-size: 1.1rem;
            font-weight: bold;
            /* color: #4b5563; Removed default gray color */
            margin-bottom: 0.5rem;
            display: flex; /* Use flexbox for icon and text */
            align-items: center; /* Align items vertically */
            gap: 0.5rem; /* Space between icon and text */
        }

        /* Specific colors for labels */
        .verse-label.shlokam {
             color: #4f46e5; /* Indigo for Shlokam label */
        }
         .verse-label.bhavartham {
             color: #d97706; /* Orange for Bhavartham label */
         }
         .verse-label.sandesham {
             color: #1d4ed8; /* Blue color for Sandesham label */
         }

         /* Styling for Audio Buttons - Refined Positioning */
         .audio-button {
             background: none;
             border: none;
             cursor: pointer;
             font-size: 1.8rem; /* Larger icon size */
             padding: 0.5rem; /* Increased padding */
             color: #4f46e5; /* Indigo color */
             transition: color 0.2s ease-in-out;
             display: flex; /* Use flexbox for centering icon */
             align-items: center;
             justify-content: center;
             /* Positioned absolutely within the Sanskrit tile */
             position: absolute;
             top: 0.5rem; /* Adjust top position */
             right: 0.5rem; /* Adjust right position */
             z-index: 10; /* Ensure it's above other tile content */
             /* Added transform to fine-tune vertical alignment relative to its position */
             transform: translateY(-10%); /* Adjust vertically */
         }

         .audio-button:hover {
             color: #4338ca; /* Darker indigo on hover */
         }

         /* Styling for the new content cards/tiles */
         .content-card {
             background-color: rgba(255, 255, 255, 0.8); /* Slightly more transparent white background for cards */
             border-radius: 0.75rem; /* Slightly less rounded than main card */
             padding: 1.5rem; /* Padding inside cards */
             margin-top: 0.8rem; /* Space above each card - Reduced slightly */
             box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* Subtle shadow for cards */
             border: 1px solid #e5e7eb; /* Subtle border */
         }

         /* Specific styles for different content cards */
         .content-card.shlokam {
             border-left: 5px solid #4f46e5; /* Indigo border on the left */
         }
         .content-card.bhavartham {
             border-left: 5px solid #d97706; /* Orange border on the left */
         }
          .content-card.sandesham {
             border-left: 5px solid #1d4ed8; /* Blue border on the left */
         }


        .card {
            background-color: rgba(255, 255, 255, 0.8); /* Increased transparency for the main card */
            border-radius: 1rem; /* More rounded corners */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15); /* More prominent shadow */
            padding: 2rem; /* Increased padding */
            margin-bottom: 2rem; /* Increased margin */
            border: 1px solid #e5e7eb; /* Subtle border */
        }
        .controls { /* Targeting the controls div */
             background-color: rgba(255, 255, 255, 0.8); /* Increased transparency for controls */
             border-radius: 0.75rem; /* Rounded corners */
             box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* Subtle shadow */
             padding: 1.5rem; /* Padding */
             margin-bottom: 1.5rem; /* Margin below */
             border: 1px solid #e5e7eb; /* Subtle border */
        }

        .input-group {
            display: flex;
            gap: 0.75rem; /* Increased gap */
            margin-bottom: 1.5rem; /* Increased margin */
            flex-direction: column; /* Stack vertically by default */
        }

        @media (min-width: 640px) { /* Tailwind's 'sm' breakpoint */
            .input-group {
                flex-direction: row; /* Arrange horizontally on larger screens */
            }
             .input-group select {
                flex-grow: 1;
            }
        }

        .input-group input,
        .input-group select {
            flex-grow: 1;
            padding: 0.9rem; /* Increased padding */
            border: 1px solid #d1d5db;
            border-radius: 0.5rem; /* More rounded input corners */
            background-color: #f9fafb;
            height: 48px; /* Increased height */
            font-size: 1rem; /* Standard font size */
        }

         .input-group select {
             appearance: none;
             background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.362%22%20height%3D%22292.362%22%3E%3Cpath%20fill%3D%22%231f2937%22%20d%3D%22M287.9.953a14.618%2014.618%200%200%200-21.04%200l-118.9%20118.8-118.9-118.8a14.618%2014.618%200%200%200-21.04%200%2014.618%2014.618%200%200%200%200%2021.04l129.4%20129.4a14.618%2014.618%200%200%200%2021.04%200l129.4-129.4a14.618%2014.618%200%200%200%200-21.04z%22%2F%3E%3C%2Fsvg%3E");
             background-repeat: no-repeat;
             background-position: right 0.9rem center; /* Adjusted position */
             background-size: 0.7em auto; /* Slightly larger arrow */
             padding-right: 3rem; /* Increased padding for arrow */
         }


        .btn {
            padding: 1rem 2rem; /* Increased padding */
            border-radius: 0.75rem; /* More rounded buttons */
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15); /* More prominent button shadow */
            display: flex; /* Use flexbox for icon and text alignment */
            align-items: center;
            justify-content: center;
            gap: 0.5rem; /* Space between icon and text */
            font-size: 1.1rem; /* Slightly larger font size */
        }
        .btn:hover {
             box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2); /* Hover shadow effect */
        }
        .btn-primary {
            background-color: #4f46e5; /* Indigo */
            color: white;
        }
        .btn-primary:hover {
            background-color: #4338ca; /* Darker indigo */
        }
         .btn-secondary {
            background-color: #10b981; /* Emerald */
            color: white;
        }
        .btn-secondary:hover {
            background-color: #059669; /* Darker emerald */
        }
        .message {
            margin-top: 1.5rem; /* Increased margin */
            padding: 1rem; /* Increased padding */
            border-radius: 0.5rem; /* More rounded corners */
            font-weight: medium;
            font-size: 1rem;
        }
        .message.error {
            background-color: rgba(254, 226, 226, 0.9); /* Red background with transparency */
            color: #991b1b; /* Dark red text */
            border: 1px solid #f87171;
        }
         .message.info {
            background-color: rgba(219, 234, 254, 0.9); /* Blue background with transparency */
            color: #1e40af; /* Dark blue text */
             border: 1px solid #93c5fd;
        }

        /* Confetti/Flower Effect Styling */
         .confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow interaction with elements below */
            overflow: hidden; /* Prevent confetti from overflowing */
            z-index: 99; /* Below splash screen */
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #ff0; /* Default color (yellow) */
            border-radius: 50%;
            animation: fall linear;
            opacity: 0; /* Start hidden */
        }

        /* Define different colors for confetti */
        .confetti:nth-child(3n+1) { background-color: #f00; } /* Red */
        .confetti:nth-child(3n+2) { background-color: #0f0; } /* Green */
        .confetti:nth-child(3n+3) { background-color: #00f; } /* Blue */
        .confetti:nth-child(5n+1) { background-color: #ff00ff; } /* Magenta */
        .confetti:nth-child(5n+2) { background-color: #00ffff; } /* Cyan */
        .confetti:nth-child(5n+3) { background-color: #ffa500; } /* Orange */


        /* Animation for falling confetti */
        @keyframes fall {
            0% {
                transform: translateY(-100px) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }

        /* Social Share Styling */
        .share-container {
            margin-top: 2rem;
            padding-top: 1.5rem;
            border-top: 1px solid #d1d5db;
            text-align: center;
        }

        .share-container p {
            font-size: 1.1rem;
            color: #4b5563;
            margin-bottom: 1rem;
        }

        .share-buttons {
            display: flex;
            justify-content: center;
            gap: 0.75rem; /* Reduced gap between icons */
            flex-wrap: wrap; /* Allow wrapping on small screens */
             /* Align icons to the top of the container */
            align-items: flex-start;
        }

        .share-button {
            display: inline-flex;
            align-items: center;
            justify-content: center; /* Center icon within the button */
            width: 40px; /* Fixed width for a small circle */
            height: 40px; /* Fixed height for a small circle */
            padding: 0; /* Remove padding */
            border-radius: 50%; /* Make it round */
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, opacity 0.2s ease-in-out;
            font-size: 1.2rem; /* Icon size */
            color: white; /* Icon color */
        }

        .share-button i {
            margin-right: 0; /* Remove margin next to icon */
        }

        .share-button.whatsapp {
            background-color: #25d366; /* WhatsApp Green */
        }
        .share-button.whatsapp:hover {
            background-color: #128c7e;
        }

        .share-button.facebook {
            background-color: #1877f2; /* Facebook Blue */
        }
        .share-button.facebook:hover {
            background-color: #0b65c2;
        }

        .share-button.twitter {
            background-color: #1da1f2; /* Twitter Blue */
        }
        .share-button.twitter:hover {
            background-color: #0c85d0;
        }

        /* Instagram sharing is typically done via Web Share API or deep linking,
           direct web share buttons are less common/reliable. We'll rely on Web Share API
           or a generic copy-to-clipboard for Instagram. */
        .share-button.generic {
             background-color: #6b7280; /* Gray */
        }
         .share-button.generic:hover {
             background-color: #4b5563;
         }


        /* Footer Styling */
        footer {
            margin-top: auto; /* Push footer to the bottom */
            padding: 1.5rem;
            text-align: center;
            font-size: 0.9rem;
            color: #6b7280; /* Gray text */
            background-color: rgba(255, 255, 255, 0.8); /* Semi-transparent white background */
            border-top: 1px solid #d1d5db;
        }

        footer a {
            color: #4f46e5; /* Indigo link color */
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        /* --- Side Menu Styling --- */
        .side-menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent black overlay */
            z-index: 20; /* Above main content, below menu */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }

        .side-menu-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .side-menu {
            position: fixed;
            top: 0;
            left: -80%; /* Start off-screen */
            width: 80%; /* Menu width */
            max-width: 300px; /* Max width for larger screens */
            height: 100%;
            background-color: #ffffff; /* White background */
            z-index: 30; /* Above overlay */
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.2); /* Shadow on the right edge */
            transition: left 0.3s ease-in-out; /* Slide transition */
            padding: 1.5rem; /* Padding inside the menu */
            overflow-y: auto; /* Enable scrolling if content overflows */
            display: flex;
            flex-direction: column;
        }

        .side-menu.open {
            left: 0; /* Slide in */
        }

        /* Burger Icon - REMOVED */


        /* Adjust main content margin - REMOVED as burger icon is gone */
        /* .main-content {
            margin-top: 3rem;
        } */

        /* Style for the side menu heading */
        .side-menu h2 {
            font-size: 1.3rem;
            font-weight: bold;
            margin-bottom: 1rem;
            color: #374151;
            font-family: 'Roboto', sans-serif;
            text-align: center;
        }

         /* Style for the controls inside the side menu */
         .side-menu .controls {
             padding: 0; /* Remove padding as it's already on the menu */
             margin-bottom: 0; /* Remove bottom margin */
             box-shadow: none; /* Remove shadow */
             border: none; /* Remove border */
             background-color: transparent; /* Transparent background */
         }

         /* Style for input groups inside the side menu */
         .side-menu .input-group {
             margin-bottom: 1rem; /* Reduced margin */
             gap: 0.5rem; /* Reduced gap */
         }

         /* Style for buttons inside the side menu */
         .side-menu .btn {
             padding: 0.8rem 1.5rem; /* Reduced padding */
             font-size: 1rem; /* Reduced font size */
             gap: 0.4rem; /* Reduced gap */
         }

         /* Subtle hint for the side menu - Enhanced Aesthetics (Peacock Feather inspired) */
         .side-menu-hint {
             position: fixed;
             top: 50%;
             left: 0;
             transform: translateY(-50%);
             width: 15px; /* Wider bar */
             height: 120px; /* Significantly taller */
             /* Peacock Feather Gradient */
             background: linear-gradient(to bottom, #008080, #4682b4, #008080); /* Teal, Steel Blue, Teal */
             z-index: 10; /* Below main content */
             border-top-right-radius: 15px; /* More rounded */
             border-bottom-right-radius: 15px; /* More rounded */
             transition: width 0.3s ease-in-out, background 0.3s ease-in-out; /* Transition background too */
             cursor: grab; /* Indicate it's draggable */
             box-shadow: 1px 1px 5px rgba(0, 0, 0, 0.3); /* More prominent shadow */
         }

         .side-menu-hint:hover {
             width: 20px; /* Wider on hover */
             background: linear-gradient(to bottom, #006666, #3a6b94, #006666); /* Slightly darker gradient on hover */
         }

         /* Add a pulse animation to the hint */
         @keyframes pulse-hint {
             0% { opacity: 0.7; transform: translateY(-50%) scale(1); }
             50% { opacity: 1; transform: translateY(-50%) scale(1.05); }
             100% { opacity: 0.7; transform: translateY(-50%) scale(1); }
         }

         .side-menu-hint {
             animation: pulse-hint 2s infinite ease-in-out; /* Apply pulse animation */
         }

         /* Styling for highlighted words */
         .highlighted-word {
             background-color: rgba(255, 255, 0, 0.5); /* Semi-transparent yellow highlight */
             padding: 0 2px; /* Add a little padding around the highlight */
             border-radius: 3px; /* Slightly rounded corners for highlight */
         }

         /* Styling for the app version display in the side menu */
         #appVersionDisplay {
             margin-top: auto; /* Push to the bottom */
             padding-top: 1rem;
             border-top: 1px solid #e5e7eb;
             font-size: 0.8rem;
             color: #6b7280;
             text-align: center;
         }


        /* --- Landscape Optimization for small screens --- */
        @media (orientation: landscape) and (max-width: 768px) {
            #appHeading {
                font-size: 2rem; /* Slightly smaller */
                margin-bottom: 1rem;
            }
            /* .main-content margin-top removed */
            #sanskritVerseTile {
                 margin-top: 0.8rem;
                 margin-bottom: 0.8rem;
                 padding: 0.8rem;
            }
             .sanskrit-verse-text {
                 font-size: 1.2rem;
             }
             .sanskrit-tile-info {
                 font-size: 0.7rem;
                 margin-bottom: 0.2rem;
             }
            .verse-label {
                margin-top: 0.6rem;
                margin-bottom: 0.3rem;
                 font-size: 1rem;
            }
            .content-card {
                margin-top: 0.6rem;
                padding: 1rem;
                 border-left-width: 3px;
            }
             .polished-telugu-verse-text {
                 font-size: 1.3rem;
             }
             .telugu-bhavartham-text {
                 font-size: 1.2rem;
             }
             .sandesham-text {
                 font-size: 1rem;
             }
             .audio-button {
                 top: 0.3rem;
                 right: 0.3rem;
                 font-size: 1.6rem;
             }
             .card {
                 padding: 1.5rem;
             }
             .share-container {
                 margin-top: 1.5rem;
                 padding-top: 1rem;
             }
              .share-container p {
                 font-size: 1rem;
             }
             .share-buttons {
                 gap: 0.5rem;
             }
              .share-button {
                 width: 35px;
                 height: 35px;
                 font-size: 1.1rem;
             }
             /* Burger icon rules removed */

             .side-menu {
                 width: 90%; /* Wider menu in landscape */
             }
             .side-menu-hint {
                 height: 80px; /* Shorter hint in landscape */
                 /* Disable pulse animation in landscape to be less distracting */
                 animation: none;
             }


        }


    </style>
</head>
<body>

    <div class="splash-screen" id="splashScreen">
        <h1>శ్రీమద్భగవద్గీత</h1>
        <p>తెలుగులో</p>
        </div>

    <div class="side-menu-overlay" id="sideMenuOverlay"></div>

    <div class="side-menu" id="sideMenu">
         <h2>ఒక శ్లోకం పొందండి</h2>
         <div class="controls"> <div class="input-group">
                <select id="chapterSelect" class="focus:ring-blue-500 focus:border-blue-500 font-roboto">
                    <option value="">అధ్యాయం ఎంచుకోండి</option>
                </select>
                <select id="verseSelect" class="focus:ring-blue-500 focus:border-blue-500 font-roboto" disabled>
                    <option value="">శ్లోకం ఎంచుకోండి</option>
                </select>
            </div>
            <button class="btn btn-primary w-full mb-3 font-roboto" id="fetchSpecificVerseBtn">
                 <i class="ph ph-book-open"></i> నిర్దిష్ట శ్లోకం పొందండి
            </button>
            <button class="btn btn-secondary w-full font-roboto" id="fetchRandomVerseBtn">
                 <i class="ph ph-shuffle"></i> యాదృచ్ఛిక శ్లోకం పొందండి
            </button>
        </div>
        <div id="appVersionDisplay"></div>
    </div>

    <div class="side-menu-hint" id="sideMenuHint" title="మెనూ తెరవడానికి స్వైప్ చేయండి"></div>


    <div class="main-content container mx-auto p-4 md:p-8" id="mainContent">
        <h1 id="appHeading">శ్రీమద్భగవద్గీత</h1>

        <div id="verseDisplay" class="card hidden">
            </div>

        <div id="messageArea" class="message hidden"></div>

    </div>

    <div class="confetti-container" id="confettiContainer"></div>

    <footer>
        &copy; 2025 <a href="https://adabala.com" target="_blank">adabala.com</a>. All rights reserved.
    </footer>

    <script>
        const splashScreen = document.getElementById('splashScreen');
        const mainContent = document.getElementById('mainContent');
        const verseDisplay = document.getElementById('verseDisplay');
        const chapterSelect = document.getElementById('chapterSelect');
        const verseSelect = document.getElementById('verseSelect');
        const fetchSpecificVerseBtn = document.getElementById('fetchSpecificVerseBtn');
        const fetchRandomVerseBtn = document.getElementById('fetchRandomVerseBtn');
        const messageArea = document.getElementById('messageArea');
        const confettiContainer = document.getElementById('confettiContainer');

        const sideMenu = document.getElementById('sideMenu');
        const sideMenuOverlay = document.getElementById('sideMenuOverlay');
        const sideMenuHint = document.getElementById('sideMenuHint');
        const appVersionDisplay = document.getElementById('appVersionDisplay'); // Get the version display element


        // Base URL for your Flask API
        // Ensure this is HTTPS if your PWA is on HTTPS (like GitHub Pages)
        const API_BASE_URL = 'https://gita.adabala.com'; // UPDATE THIS IF YOUR API URL CHANGES

        // Simple local cache using localStorage
        let verseCache = JSON.parse(localStorage.getItem('bhagavathGitaCache')) || {};
        const CACHE_KEY = 'bhagavathGitaCache'; // Key for localStorage

        // Define the number of verses in each chapter (same as backend)
        const CHAPTER_VERSE_COUNTS = {
            1: 46, 2: 72, 3: 43, 4: 42, 5: 29, 6: 47,
            7: 30, 8: 28, 9: 34, 10: 42, 11: 55, 12: 20,
            13: 35, 14: 27, 15: 20, 16: 24, 17: 28, 18: 78,
        };

        // Initialize Speech Synthesis
        const synth = window.speechSynthesis;
        let currentUtterance = null; // To keep track of the current speech
        let wordSpans = []; // Array to store references to word spans and their text/index info
        let currentHighlightSpan = null; // To keep track of the currently highlighted span
        let isMuted = false; // State for mute/unmute

        // Function to show messages
        function showMessage(msg, type = 'info', area = messageArea) {
            area.textContent = msg;
            area.className = `message ${type}`;
            area.classList.remove('hidden');
        }

        // Function to hide messages
        function hideMessage(area = messageArea) {
            area.classList.add('hidden');
        }

        // Function to trigger confetti/flower effect
        function triggerConfetti() {
            const numConfetti = 50; // Number of confetti pieces
            const colors = ['#ff0', '#f00', '#0f0', '#0f0', '#ff00ff', '#00ffff', '#ffa500']; // Confetti colors (added more green)
            const emojis = ['🌸', '🌼', '🌺', '🌻', '🌹', '🌷']; // Flower emojis (optional)
            const animationDuration = '3s'; // Duration for one fall animation

            // Clear any existing confetti
            confettiContainer.innerHTML = '';

            for (let i = 0; i < numConfetti; i++) {
                const confetti = document.createElement('div');
                confetti.classList.add('confetti');

                // Randomly choose between a colored circle or an emoji
                if (Math.random() > 0.4 && emojis.length > 0) { // Slightly increased chance of emoji
                     confetti.textContent = emojis[Math.floor(Math.random() * emojis.length)];
                     confetti.style.backgroundColor = 'transparent'; // No background for emoji
                     confetti.style.fontSize = `${Math.random() * 20 + 10}px`; // Random size for emoji
                     confetti.style.width = 'auto'; // Adjust width for emoji
                     confetti.style.height = 'auto'; // Adjust height for emoji
                } else {
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                }


                confetti.style.left = `${Math.random() * 100}vw`; // Random horizontal position
                // Set animation duration and delay
                confetti.style.animationDuration = animationDuration;
                confetti.style.animationDelay = `${Math.random() * 0.5}s`; // Random delay for staggered effect
                confetti.style.opacity = 1; // Make visible when animation starts


                confettiContainer.appendChild(confetti);

                // Remove confetti after animation finishes
                confetti.addEventListener('animationend', () => {
                    confetti.remove();
                });
            }
        }

        // Function to wrap words in spans and build wordSpans array
        // This function now takes the text to wrap, the container, and the *start index in the full spoken text*
        function wrapWordsInSpans(textToWrap, containerElement, startIndexInFullSpokenText) {
            const words = textToWrap.split(/\s+/); // Split by one or more whitespace characters
            let currentHtml = '';
            let currentSpokenIndex = startIndexInFullSpokenText; // Index in the full spoken text

            words.forEach((word, index) => {
                if (word) { // Avoid creating spans for empty strings from multiple spaces
                    // Add a space before the word in HTML if it's not the first word in this segment
                    if (index > 0) {
                         currentHtml += ' ';
                         // We don't increment currentSpokenIndex for the space here because
                         // the onboundary event gives the start of the word itself in the spoken text.
                         // The mapping relies on finding the word in the spoken string.
                    }

                    // Create a span for the word
                    const span = document.createElement('span');
                    span.textContent = word;
                    span.classList.add('verse-word'); // Add a class for styling/selection

                    // Store word info and span reference
                    wordSpans.push({
                        text: word,
                        // Store the approximate start index in the full spoken text string
                        // This is an approximation and might need fine-tuning based on TTS behavior
                        startIndex: currentSpokenIndex,
                        endIndex: currentSpokenIndex + word.length, // Approximate end index
                        span: span // Store reference to the actual span element
                    });

                    currentHtml += span.outerHTML; // Add the span HTML
                    currentSpokenIndex += word.length; // Increment index by word length

                    // Add 1 for the space that will follow this word in the spoken text (if not the last word)
                    if (index < words.length - 1) {
                         currentSpokenIndex += 1; // Account for the space *after* the word
                    }
                }
            });

            containerElement.innerHTML = currentHtml; // Set the HTML of the container
            return currentSpokenIndex; // Return the ending index in the full spoken text after this segment
        }


        // Function to speak text and handle highlighting
        function speakText(text, lang = 'te-IN') {
            // Stop any ongoing speech before starting new speech and clear highlight
            if (synth.speaking) {
                synth.cancel();
                clearHighlight();
            }

            if (isMuted) {
                 console.log("Speech is muted. Not speaking.");
                 // Ensure icon is correct if speech was attempted while muted
                 const audioButton = verseDisplay.querySelector('#playAllAudio');
                 if (audioButton) {
                     const icon = audioButton.querySelector('i');
                     icon.classList.remove('ph-speaker-high');
                     icon.classList.add('ph-speaker-slash');
                     audioButton.title = 'అన్‌మ్యూట్ చేయండి';
                 }
                 return; // Don't speak if muted
            }

            if (text && text.trim() !== '') {
                currentUtterance = new SpeechSynthesisUtterance(text);
                currentUtterance.lang = lang; // Set language (Telugu for te-IN, Sanskrit might need a different approach or voice)

                // Event listener for word boundaries
                currentUtterance.onboundary = (event) => {
                    if (event.name === 'word') {
                        const charIndex = event.charIndex;
                        // Find the word span whose *spoken text index range* contains this charIndex
                        // This is the core mapping from spoken text index to displayed word span
                        const targetWordInfo = wordSpans.find(wordInfo => {
                             // A simple check: see if the spoken text at charIndex starts with the word's text
                             // This is more robust than relying purely on calculated indices
                             const spokenSegment = text.substring(charIndex);
                             // Clean the spoken segment and word text for comparison (remove punctuation, normalize space)
                             const cleanSpokenSegment = spokenSegment.replace(/[\s.,!?;:]+/g, ' ').trim();
                             const cleanWordText = wordInfo.text.replace(/[\s.,!?;:]+/g, ' ').trim();

                             // Check if the cleaned spoken segment starts with the cleaned word text
                             // Also check if the charIndex falls within the approximate range stored
                             return cleanSpokenSegment.startsWith(cleanWordText) &&
                                    charIndex >= wordInfo.startIndex && charIndex < wordInfo.endIndex + (wordInfo.text.length * 0.5); // Add a buffer for approximation
                        });


                        if (targetWordInfo) {
                            clearHighlight(); // Remove previous highlight
                            currentHighlightSpan = targetWordInfo.span;
                            currentHighlightSpan.classList.add('highlighted-word');

                            // Scroll the word into view
                            targetWordInfo.span.scrollIntoView({
                                behavior: 'smooth', // Smooth scrolling
                                block: 'center' // Center the word in the viewport
                            });
                        } else {
                             // Handle cases where charIndex might not perfectly match (e.g., punctuation, TTS variations)
                             // This can happen if the simple startsWith check fails or indices are off.
                             // We can try a fallback: find the word span whose text is nearest to the spoken word at charIndex.
                             // Or, log a warning and skip highlighting for this word.
                             console.warn('Could not find word span for charIndex:', charIndex, 'Spoken text snippet:', text.substring(charIndex, charIndex + 20) + '...');
                             // Optional: Add more sophisticated fuzzy matching or index correction here if needed.
                        }
                    }
                };

                // Event listener for end of speech
                currentUtterance.onend = () => {
                    clearHighlight(); // Clear highlight when speech ends
                     console.log("Speech ended.");
                     // After speech ends, if not muted, revert icon to high speaker
                     const audioButton = verseDisplay.querySelector('#playAllAudio');
                     if (audioButton && !isMuted) {
                         const icon = audioButton.querySelector('i');
                         icon.classList.remove('ph-speaker-slash');
                         icon.classList.add('ph-speaker-high');
                         audioButton.title = 'అన్నీ వినండి / ఆపు';
                     }
                };

                // Event listener for errors
                 currentUtterance.onerror = (event) => {
                     console.error('SpeechSynthesisUtterance error:', event.error);
                     showMessage(`వచనాన్ని చదవడంలో లోపం: ${event.error}`, 'error'); // Error reading text
                     clearHighlight(); // Clear highlight on error
                 };

                // Before speaking, update the icon to indicate speaking is starting (high speaker)
                 const audioButton = verseDisplay.querySelector('#playAllAudio');
                 if (audioButton) {
                     const icon = audioButton.querySelector('i');
                     icon.classList.remove('ph-speaker-slash');
                     icon.classList.add('ph-speaker-high');
                     audioButton.title = 'అన్నీ వినండి / ఆపు'; // Or 'ఆపు'
                 }


                synth.speak(currentUtterance);
            } else {
                 console.warn("No text provided to speakText function or text is empty.");
                 // If there's no text to speak, ensure the icon is not stuck in a playing state
                 const audioButton = verseDisplay.querySelector('#playAllAudio');
                 if (audioButton) {
                     const icon = audioButton.querySelector('i');
                     if (!isMuted) { // If not muted, should show high speaker
                         icon.classList.remove('ph-speaker-slash');
                         icon.classList.add('ph-speaker-high');
                         audioButton.title = 'అన్నీ వినండి / ఆపు';
                     } else { // If muted, should show slash speaker
                         icon.classList.remove('ph-speaker-high');
                         icon.classList.add('ph-speaker-slash');
                         audioButton.title = 'అన్‌మ్యూట్ చేయండి';
                     }
                 }
            }
        }

        // Function to clear highlighting
        function clearHighlight() {
            if (currentHighlightSpan) {
                currentHighlightSpan.classList.remove('highlighted-word');
                currentHighlightSpan = null;
            }
             // Also remove highlight from all spans just in case
             document.querySelectorAll('.verse-word.highlighted-word').forEach(span => {
                 span.classList.remove('highlighted-word');
             });
        }

        // Function to toggle mute state and update icon
        function toggleMute() {
            isMuted = !isMuted;
            const audioButton = verseDisplay.querySelector('#playAllAudio');
            if (audioButton) {
                 const icon = audioButton.querySelector('i');
                 if (isMuted) {
                     synth.cancel(); // Stop speech immediately when muting
                     clearHighlight(); // Clear highlight on mute
                     // Update icon to muted state
                     icon.classList.remove('ph-speaker-high');
                     icon.classList.add('ph-speaker-slash');
                     audioButton.title = 'అన్‌మ్యూట్ చేయండి'; // Update title
                     console.log("Muted.");
                 } else {
                     // Update icon to unmuted state
                     icon.classList.remove('ph-speaker-slash');
                     icon.classList.add('ph-speaker-high');
                     audioButton.title = 'అన్నీ వినండి / ఆపు'; // Update title
                     console.log("Unmuted.");
                     // Note: Unmuting doesn't automatically resume speech.
                     // The user needs to click the button again to start speaking.
                     // If speech was stopped due to muting, clicking again will restart it.
                 }
            } else {
                 console.warn("Audio button not found when toggling mute.");
            }
        }


        // Function to display a verse in the new format (using cards)
        function displayVerse(verseData) {
            hideMessage(); // Hide main message area
            clearHighlight(); // Clear any highlight from previous verse
            wordSpans = []; // Reset word spans array for the new verse

            // Clear previous content
            verseDisplay.innerHTML = '';

            // Construct the new display structure
            // Use polished versions if available, otherwise fallback to original fetched
            const sanskritVerse = verseData.sanskrit_verse_telugu_script; // Get Sanskrit verse (can be null)
            const polishedTeluguVerse = verseData.polished_telugu_verse || verseData.telugu_verse || 'తెలుగు శ్లోకం అందుబాటులో లేదు.';
            const polishedTeluguMeaning = verseData.polished_telugu_meaning || verseData.telugu_meaning || 'తెలుగు భావార్థం అందుబాటులో లేదు.';
            const teluguDescription = verseData.telugu_description || 'సందేశం అందుబాటులో లేదు.';

            // Build the full text to speak (including labels and pauses)
            let fullTextToSpeak = '';
            if (sanskritVerse && sanskritVerse.trim() !== '' && sanskritVerse !== 'సంస్కృత శ్లోకం అందుబాటులో లేదు.') {
                 fullTextToSpeak += `అధ్యాయం ${verseData.chapter}, శ్లోకం ${verseData.verse}. సంస్కృత శ్లోకం. ${sanskritVerse.trim()}. `;
            }
            if (polishedTeluguVerse && polishedTeluguVerse !== 'తెలుగు శ్లోకం అందుబాటులో లేదు.') {
                 fullTextToSpeak += `తెలుగు శ్లోకం. ${polishedTeluguVerse}. `;
            }
            if (polishedTeluguMeaning && polishedTeluguMeaning !== 'తెలుగు భావార్థం అందుబాటులో లేదు.') {
                 fullTextToSpeak += `భావార్థం. ${polishedTeluguMeaning}. `;
            }
             if (teluguDescription && teluguDescription !== 'సందేశం అందుబాటులో లేదు.') {
                fullTextToSpeak += `సందేశం. ${teluguDescription}. `;
            }


            let contentHTML = ``; // Start with empty HTML as main heading is removed

            // Only add Sanskrit verse tile if it exists and is not the fallback message or empty
            if (sanskritVerse && sanskritVerse.trim() !== '' && sanskritVerse !== 'సంస్కృత శ్లోకం అందుబాటులో లేదు.') {
                 contentHTML += `
                    <div id="sanskritVerseTile">
                         <div class="sanskrit-tile-info">
                            అధ్యాయం [${verseData.chapter}], శ్లోకం [${verseData.verse}]:
                         </div>
                         <div id="sanskritVerse" class="sanskrit-verse-text">
                             </div>
                         <button class="audio-button" id="playAllAudio" title="${isMuted ? 'అన్‌మ్యూట్ చేయండి' : 'అన్నీ వినండి / ఆపు'}">
                             <i class="ph ${isMuted ? 'ph-speaker-slash' : 'ph-speaker-high'}"></i>
                         </button>
                    </div>
                 `;
            }

            // Add Shlokam Card
            contentHTML += `
                <div id="teluguVerseContainer" class="content-card shlokam">
                    <div class="verse-label shlokam"><i class="ph ph-book-open"></i> శ్లోకం:</div>
                     <div id="teluguVerse" class="polished-telugu-verse-text">
                         </div>
                </div>
            `;

            // Add Bhavartham Card
            contentHTML += `
                <div id="teluguBhavarthamContainer" class="content-card bhavartham">
                    <div class="verse-label bhavartham"><i class="ph ph-lightbulb"></i> భావార్థం:</div>
                     <div id="teluguBhavartham" class="telugu-bhavartham-text">
                         </div>
                </div>
            `;

            // Add Sandesham Card
            contentHTML += `
                <div id="sandeshamContainer" class="content-card sandesham">
                     <div class="verse-label sandesham"><i class="ph ph-chat-centered-text"></i> సందేశం:</div>
                     <div id="sandesham" class="sandesham-text">
                         </div>
                </div>
            `;


            contentHTML += `
                <div class="share-container">
                    <p class="font-roboto">ఈ శ్లోకాన్ని పంచుకోండి:</p>
                    <div class="share-buttons">
                        <button class="share-button whatsapp" data-platform="whatsapp" title="Share on WhatsApp">
                            <i class="ph ph-whatsapp-logo"></i>
                        </button>
                        <button class="share-button facebook" data-platform="facebook" title="Share on Facebook">
                             <i class="ph ph-facebook-logo"></i>
                        </button>
                         <button class="share-button twitter" data-platform="twitter" title="Share on Twitter">
                             <i class="ph ph-twitter-logo"></i>
                        </button>
                         <button class="share-button generic" data-platform="generic" title="Share or Copy">
                             <i class="ph ph-share-network"></i>
                        </button>
                    </div>
                </div>
            `;

            verseDisplay.innerHTML = contentHTML;
            verseDisplay.classList.remove('hidden');

            // Now populate the text content and wrap words in spans
            // Get the container elements *after* they have been added to the DOM
            const sanskritVerseElement = verseDisplay.querySelector('#sanskritVerse');
            const teluguVerseElement = verseDisplay.querySelector('#teluguVerse');
            const teluguBhavarthamElement = verseDisplay.querySelector('#teluguBhavartham');
            const sandeshamElement = verseDisplay.querySelector('#sandesham');

            // Keep track of the current index in the fullTextToSpeak string for word wrapping
            let currentSpokenIndex = 0;

            // Wrap Sanskrit verse words
             if (sanskritVerseElement && sanskritVerse && sanskritVerse.trim() !== '' && sanskritVerse !== 'సంస్కృత శ్లోకం అందుబాటులో లేదు.') {
                 const sanskritInfoText = `అధ్యాయం ${verseData.chapter}, శ్లోకం ${verseData.verse}. సంస్కృత శ్లోకం. `;
                 currentSpokenIndex += sanskritInfoText.length; // Account for the label text
                 currentSpokenIndex = wrapWordsInSpans(sanskritVerse.trim(), sanskritVerseElement, currentSpokenIndex);
                 currentSpokenIndex += 2; // Account for the ". " added after the Sanskrit verse in fullTextToSpeak
             } else if (sanskritVerseElement) {
                 // If Sanskrit verse is not available, set the fallback text directly without wrapping
                 sanskritVerseElement.textContent = sanskritVerse || 'సంస్కృత శ्लोకం అందుబాటులో లేదు.';
             }


             // Wrap Telugu verse words
             if (teluguVerseElement) {
                 const teluguVerseLabelText = `తెలుగు శ్లోకం. `;
                 currentSpokenIndex += teluguVerseLabelText.length; // Account for the label text
                 currentSpokenIndex = wrapWordsInSpans(polishedTeluguVerse, teluguVerseElement, currentSpokenIndex);
                 currentSpokenIndex += 2; // Account for the ". " added after the Telugu verse in fullTextToSpeak
             }


             // Wrap Bhavartham words
             if (teluguBhavarthamElement) {
                 const teluguBhavarthamLabelText = `భావార్థం. `;
                 currentSpokenIndex += teluguBhavarthamLabelText.length; // Account for the label text
                 currentSpokenIndex = wrapWordsInSpans(polishedTeluguMeaning, teluguBhavarthamElement, currentSpokenIndex);
                 currentSpokenIndex += 2; // Account for the ". " added after the Bhavartham in fullTextToSpeak
             }


             // Wrap Sandesham words
             if (sandeshamElement) {
                 const sandeshamLabelText = `సందేశం. `;
                 currentSpokenIndex += sandeshamLabelText.length; // Account for the label text
                 currentSpokenIndex = wrapWordsInSpans(teluguDescription, sandeshamElement, currentSpokenIndex);
                 currentSpokenIndex += 2; // Account for the ". " added after the Sandesham in fullTextToSpeak
             }


            // --- Auto-play TTS ---
            // Check if TTS is available and enabled (though we want it default,
            // some environments might disable it or require user interaction first)
            // Only auto-play if not muted
            if (synth && fullTextToSpeak && fullTextToSpeak.trim() !== '' && !isMuted) {
                 console.log("Auto-playing speech.");
                 // A small delay might be needed on some mobile browsers for TTS to initialize fully
                 setTimeout(() => {
                     speakText(fullTextToSpeak.trim(), 'te-IN'); // Auto-play the concatenated text, trim again just in case
                 }, 100); // Small delay
            } else if (fullTextToSpeak.trim() === '') {
                 console.warn("No text to speak.");
                 showMessage('వచనం అందుబాటులో లేదు.', 'info'); // No text available.
            } else if (isMuted) {
                 console.log("App is muted, not auto-playing speech.");
            }


            // Add event listener to the single play all audio button (now also acts as stop/restart/mute/unmute)
            const playAllAudioButton = verseDisplay.querySelector('#playAllAudio');
            if (playAllAudioButton) {
                // Remove any existing listener to prevent duplicates before adding a new one
                const old_element = playAllAudioButton;
                const new_element = old_element.cloneNode(true); // Clone with all children (the icon)
                old_element.parentNode.replaceChild(new_element, old_element);
                const updatedPlayAllAudioButton = verseDisplay.querySelector('#playAllAudio'); // Get the new element

                updatedPlayAllAudioButton.addEventListener('click', () => {
                    console.log("Audio button clicked. Current mute state:", isMuted, "Speaking:", synth.speaking);
                    const icon = updatedPlayAllAudioButton.querySelector('i'); // Get the icon element

                    if (synth.speaking) {
                        // If currently speaking, this click acts as STOP
                        console.log("Stopping speech.");
                        synth.cancel(); // Stop speech immediately
                        clearHighlight(); // Clear highlight immediately on stop
                        // Icon should reflect the current mute state after stopping
                         if (isMuted) {
                             icon.classList.remove('ph-speaker-high');
                             icon.classList.add('ph-speaker-slash');
                             updatedPlayAllAudioButton.title = 'అన్‌మ్యూట్ చేయండి';
                         } else {
                             icon.classList.remove('ph-speaker-slash');
                             icon.classList.add('ph-speaker-high'); // Stay as high speaker if not muted
                             updatedPlayAllAudioButton.title = 'అన్నీ వినండి / ఆపు'; // Stay as Play/Stop title
                         }
                    } else {
                        // If not speaking, this click acts as a Play/Mute Toggle
                        if (isMuted) {
                             // Was muted, now unmuting and playing
                             console.log("Unmuting and starting speech.");
                             isMuted = false; // Update state
                             // Update icon to unmuted state
                             icon.classList.remove('ph-speaker-slash');
                             icon.classList.add('ph-speaker-high');
                             updatedPlayAllAudioButton.title = 'అన్నీ వినండి / ఆపు'; // Update title

                             // Start speech
                             if (fullTextToSpeak && fullTextToSpeak.trim() !== '') {
                                 speakText(fullTextToSpeak.trim(), 'te-IN');
                             } else {
                                 console.warn("No text to speak after unmuting.");
                                 showMessage('వచనం అందుబాటులో లేదు.', 'info');
                             }
                        } else {
                             // Was unmuted and not speaking, now muting
                             console.log("Muting.");
                             isMuted = true; // Update state
                             // Update icon to muted state
                             icon.classList.remove('ph-speaker-high');
                             icon.classList.add('ph-speaker-slash');
                             updatedPlayAllAudioButton.title = 'అన్‌మ్యూట్ చేయండి'; // Update title
                             // No need to cancel synth here as it's not speaking, but clear highlight just in case.
                             clearHighlight();
                        }
                    }
                });

            } else {
                console.warn("Play all audio button not found after displayVerse.");
            }


            // Trigger confetti effect after displaying the verse
            triggerConfetti();
        }

        // Function to fetch a verse from API or cache
        async function fetchVerse(chapter, verse) {
            const cacheKey = `${chapter}-${verse}`;
            const cachedData = verseCache[cacheKey]; // Read from the global verseCache variable

            // 1. Check local cache first
            if (cachedData) {
                console.log(`Serving Chapter ${chapter}, Verse ${verse} from cache.`);
                displayVerse(cachedData);
                 // No need to fetch from API if found in cache
                return;
            }

            // 2. If not in cache, fetch from API
            // Check if online before attempting to fetch
            if (!navigator.onLine) {
                 showMessage(`మీరు ఆఫ్‌లైన్‌లో ఉన్నారు మరియు శ్లోకం ${chapter}:${verse} కాష్‌లో అందుబాటులో లేదు.`, 'error'); // You are offline and verse X:Y is not available in cache.
                 verseDisplay.classList.add('hidden');
                 return; // Stop here if offline and not in cache
            }

            showMessage('శ్లోకం పొందుతోంది...'); // Getting verse...
            try {
                console.log(`Attempting to fetch from API: ${API_BASE_URL}/verse?chapter=${chapter}&verse=${verse}`); // Log the fetch URL
                const response = await fetch(`${API_BASE_URL}/verse?chapter=${chapter}&verse=${verse}`);

                if (!response.ok) {
                    let errorDetails = `HTTP error! status: ${response.status}`;
                    try {
                         const errorData = await response.json();
                         errorDetails = errorData.error || JSON.stringify(errorData);
                    } catch (jsonError) {
                         try {
                             const errorText = await response.text();
                             errorDetails = `HTTP error! status: ${response.status}, Response Text: ${errorText}`;
                         } catch (textError) {
                             errorDetails = `HTTP error! status: ${response.status}, Could not read response body.`;
                         }
                    }
                    console.error('Fetch failed with details:', errorDetails);
                    throw new Error(errorDetails);
                }

                const data = await response.json();

                // Cache the fetched data in the global variable and localStorage
                verseCache[cacheKey] = data;
                localStorage.setItem(CACHE_KEY, JSON.stringify(verseCache));
                console.log(`Fetched Chapter ${chapter}, Verse ${verse} from API and cached.`);
                console.log('Fetched data:', data); // Log the fetched data

                displayVerse(data); // This will now also trigger auto-TTS

            } catch (error) {
                console.error('Error fetching verse:', error);
                let displayMessage = `శ్లోకం పొందడంలో లోపం: ${error.message}`;
                // Check if the error is likely due to being offline
                if (error.message.includes('Failed to fetch') || navigator.onLine === false) {
                     displayMessage = `మీరు ఆఫ్‌లైన్‌లో ఉన్నారు మరియు శ్లోకం ${chapter}:${verse} కాష్‌లో అందుబాటులో లేదు.`;
                     console.log("Likely offline error, displaying specific message.");
                } else if (!error.message || error.message === '[object Object]') {
                     console.error('Raw error object:', error);
                     displayMessage = `శ్లోకం పొందడంలో లోపం. వివరాల కోసం కన్సోల్ చూడండి.`;
                }
                showMessage(displayMessage, 'error');
                verseDisplay.classList.add('hidden');
            }
        }

        // Function to fetch a random verse
        async function fetchRandomVerse() {
             // Check if offline
             if (!navigator.onLine) {
                 const cachedVerseKeys = Object.keys(verseCache);
                 if (cachedVerseKeys.length > 0) {
                     // Select a random key from the cached verses
                     const randomKey = cachedVerseKeys[Math.floor(Math.random() * cachedVerseKeys.length)];
                     const [chapter, verse] = randomKey.split('-').map(Number);
                     console.log(`Fetching random verse from cache: Chapter ${chapter}, Verse ${verse}`);
                     displayVerse(verseCache[randomKey]); // Display directly from cache
                     // Auto-TTS is handled by displayVerse
                 } else {
                     // No verses in cache and offline
                     showMessage('మీరు ఆఫ్‌లైన్‌లో ఉన్నారు మరియు కాష్‌లో శ్లోకాలు అందుబాటులో లేవు.', 'error'); // You are offline and no verses are available in cache.
                     verseDisplay.classList.add('hidden');
                 }
             } else {
                 // If online, fetch a random verse from the API (original logic)
                 const maxChapter = 18;
                 const randomChapter = Math.floor(Math.random() * maxChapter) + 1;
                 const maxVerse = CHAPTER_VERSE_COUNTS[randomChapter] || 78;
                 const randomVerse = Math.floor(Math.random() * maxVerse) + 1;

                 console.log(`Fetching random verse from API: Chapter ${randomChapter}, Verse ${randomVerse}`);
                 fetchVerse(randomChapter, randomVerse); // fetchVerse handles caching
             }
             // Close the side menu after fetching a verse
             closeSideMenu();
        }

        // Function to populate the chapter dropdown
        function populateChapterDropdown() {
            for (let i = 1; i <= 18; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `అధ్యాయం ${i}`;
                chapterSelect.appendChild(option);
            }
        }

        // Function to populate the verse dropdown based on selected chapter
        function populateVerseDropdown(chapter) {
            verseSelect.innerHTML = '<option value="">శ్లోకం ఎంచుకోండి</option>';
            verseSelect.disabled = true;

            if (chapter && CHAPTER_VERSE_COUNTS[chapter]) {
                const numVerses = CHAPTER_VERSE_COUNTS[chapter];
                for (let i = 1; i <= numVerses; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = `శ్లోకం ${i}`;
                    verseSelect.appendChild(option);
                }
                verseSelect.disabled = false;
            }
        }

        // --- Side Menu Logic ---
        function openSideMenu() {
            sideMenu.classList.add('open');
            sideMenuOverlay.classList.add('visible');
             sideMenuHint.style.display = 'none'; // Hide hint when menu is open
        }

        function closeSideMenu() {
            sideMenu.classList.remove('open');
            sideMenuOverlay.classList.remove('visible');
             // Show hint again after a delay if not in landscape on small screen
             if (!(window.matchMedia("(orientation: landscape) and (max-width: 768px)").matches)) {
                 setTimeout(() => {
                     sideMenuHint.style.display = 'block';
                 }, 500); // Show hint after menu closes
             }
        }

        // Event listeners
        fetchSpecificVerseBtn.addEventListener('click', () => {
            const chapter = parseInt(chapterSelect.value);
            const verse = parseInt(verseSelect.value);

            if (isNaN(chapter) || isNaN(verse) || chapter <= 0 || verse <= 0) {
                showMessage('దయచేసి అధ్యాయం మరియు శ్లోకం ఎంచుకోండి.', 'error');
                return;
            }

            fetchVerse(chapter, verse);
            closeSideMenu(); // Close menu after fetching
        });

        fetchRandomVerseBtn.addEventListener('click', fetchRandomVerse); // fetchRandomVerse now handles closing the menu

        chapterSelect.addEventListener('change', (event) => {
            const selectedChapter = parseInt(event.target.value);
            populateVerseDropdown(selectedChapter);
        });

        sideMenuOverlay.addEventListener('click', closeSideMenu); // Close menu when clicking overlay

        // --- Swipe Functionality for Side Menu Hint ---
        let touchStartX = 0;
        const swipeThreshold = 50; // Minimum horizontal distance for a swipe

        sideMenuHint.addEventListener('touchstart', (e) => {
            // Store the starting X position of the touch
            touchStartX = e.touches[0].clientX;
             // Prevent default behavior only if it's clearly a horizontal swipe attempt
             // This is tricky, so we'll handle it in touchmove
        });

        sideMenuHint.addEventListener('touchmove', (e) => {
            if (touchStartX === 0) return; // If touchstart didn't fire correctly

            const touchMoveX = e.touches[0].clientX;
            const diffX = touchMoveX - touchStartX;

            // Check if it's a swipe to the right and exceeds the threshold
            if (diffX > swipeThreshold) {
                openSideMenu();
                touchStartX = 0; // Reset touchStartX to prevent multiple triggers
                 e.preventDefault(); // Prevent default scrolling/behavior
            } else if (Math.abs(e.touches[0].clientY - e.changedTouches[0].clientY) > Math.abs(diffX)) {
                 // If vertical movement is greater than horizontal, it's likely a scroll,
                 // so reset touchStartX and allow default behavior.
                 touchStartX = 0;
            }
             // If diffX is positive but less than threshold, or negative, do nothing yet.
        });

        sideMenuHint.addEventListener('touchend', (e) => {
            // Reset touchStartX regardless of swipe outcome
            touchStartX = 0;
        });

        // Also add a click listener to the hint for desktop/non-swipe interaction
        sideMenuHint.addEventListener('click', openSideMenu);


        // --- Handle orientation change for hint visibility ---
        function handleOrientationChange() {
             if (window.matchMedia("(orientation: landscape) and (max-width: 768px)").matches) {
                 sideMenuHint.style.display = 'none';
             } else {
                 // Only show hint if menu is not open
                 if (!sideMenu.classList.contains('open')) {
                     sideMenuHint.style.display = 'block';
                 }
             }
        }

        // Listen for orientation changes
        window.addEventListener('orientationchange', handleOrientationChange);
        // Also check on load
        window.addEventListener('load', handleOrientationChange);


        // --- Splash Screen Logic ---
        function hideSplashScreen() {
             splashScreen.classList.add('hidden');
             mainContent.classList.add('visible');
             // Optionally fetch a random verse after splash screen hides
             fetchRandomVerse(); // Fetch a random verse on load (will use cache if offline)
        }

        // Hide splash screen after a delay, ensuring content is loaded
        window.addEventListener('load', () => {
            populateChapterDropdown(); // Populate dropdowns early
            displayAppVersion(); // Display app version on load

            // Use a combination of load event and a timeout as a fallback
            setTimeout(hideSplashScreen, 2000); // Hide after 2 seconds
        });


        // --- Social Share Logic ---
        // Update this logic to construct the share text from the displayed elements
        document.addEventListener('click', (event) => {
             // Use event delegation to handle clicks on dynamically created share buttons
             if (event.target.closest('.share-button')) {
                 const button = event.target.closest('.share-button');
                 const platform = button.dataset.platform;

                 // Get content from the displayed elements
                 const sanskritInfoElement = verseDisplay.querySelector('.sanskrit-tile-info'); // Get info from Sanskrit tile
                 const sanskritVerseElement = document.getElementById('sanskritVerse'); // Get text from Sanskrit verse div inside tile
                 const teluguVerseElement = verseDisplay.querySelector('#teluguVerse'); // Get text from shlokam card
                 const teluguBhavarthamTextElement = verseDisplay.querySelector('#teluguBhavartham'); // Get text from bhavartham card
                 const sandeshamTextElement = document.getElementById('sandesham'); // Get text from sandesham card

                 // Ensure elements exist before getting textContent and trimming
                 const sanskritInfoText = sanskritInfoElement ? sanskritInfoElement.textContent.trim() : '';
                 const sanskritVerseText = sanskritVerseElement ? sanskritVerseElement.textContent.trim() : '';
                 const teluguVerseText = teluguVerseElement ? teluguVerseElement.textContent.trim() : '';
                 const teluguBhavarthamText = teluguBhavarthamTextElement ? teluguBhavarthamTextElement.textContent.trim() : '';
                 const sandeshamText = sandeshamTextElement ? sandeshamTextElement.textContent.trim() : '';


                 // Construct the share text based on the new format
                 let shareText = ''; // Start with empty text as main heading is removed
                 // Only include Sanskrit info and verse if they exist and are not the fallback message or empty
                 if (sanskritVerseText && sanskritVerseText !== 'సంస్కృత శ్లోకం అందుబాటులో లేదు.') {
                      shareText += `${sanskritInfoText}\n${sanskritVerseText}\n\n`; // Include both info and verse
                 }

                  if (teluguVerseText && teluguVerseText !== 'తెలుగు శ్లోకం అందుబాటులో లేదు.') {
                     shareText += `శ్లోకం:\n${teluguVerseText}\n\n`; // Used new label
                 }
                 if (teluguBhavarthamText && teluguBhavarthamText !== 'తెలుగు భావార్థం అందుబాటులో లేదు.') {
                     shareText += `భావార్థం:\n${teluguBhavarthamText}\n\n`; // Used new label
                 }
                 if (sandeshamText && sandeshamText !== 'సందేశం అందుబాటులో లేదు.') {
                      shareText += `సందేశం:\n${sandeshamText}\n\n`;
                 }

                 shareText += `Source: adabala.com - https://adabalap.github.io/Gita/`; // Concise source/link


                 if (navigator.share) {
                     // Use Web Share API if available (for generic sharing)
                     if (platform === 'generic') {
                         navigator.share({
                             title: 'శ్రీమద్భగవద్గీత శ్లోకం', // Title for the share dialog
                             text: shareText, // The text content to share
                             url: 'https://adabalap.github.io/Gita/' // The URL to share
                         }).then(() => {
                             console.log('Successfully shared via Web Share API');
                         }).catch((error) => {
                             console.error('Error sharing via Web Share API:', error);
                             // Fallback for generic share if Web Share API fails
                             copyToClipboard(shareText);
                             showMessage('శ్లోకం కాపీ చేయబడింది! మీరు ఇప్పుడు దీన్ని ఎక్కడైనా పంచుకోవచ్చు.', 'info'); // Verse copied! You can now share it anywhere.
                         });
                     } else {
                          // For specific platforms, try Web Share API first, then fallback
                          // Web Share API is the preferred method as it leverages native sharing.
                          navigator.share({
                             title: 'శ్రీమద్భగవద్గీత శ్లోకం',
                             text: shareText,
                             url: 'https://adabalap.github.io/Gita/'
                          }).then(() => {
                              console.log(`Successfully shared to ${platform} via Web Share API`);
                          }).catch((error) => {
                              console.error(`Error sharing to ${platform} via Web Share API:`, error);
                              // Fallback to specific platform web intents if Web Share API fails
                              handleSpecificPlatformShare(platform, shareText);
                          });
                     }
                 } else {
                     // Fallback for browsers that don't support Web Share API
                     handleSpecificPlatformShare(platform, shareText);
                 }
             }
        });


        // Fallback function for specific platform sharing (opens new tab)
        // Note: Web Share API is generally more reliable for opening native apps
        // compared to these web intents, which might open the web version or fail.
        function handleSpecificPlatformShare(platform, text) {
             const url = encodeURIComponent(text);
             let shareUrl = '';

             switch (platform) {
                 case 'whatsapp':
                     // WhatsApp Web Share URL
                     shareUrl = `https://wa.me/?text=${url}`;
                     // Alternative: whatsapp://send?text=${url} (might work better on some mobile devices, but less universally supported)
                     break;
                 case 'facebook':
                     // Facebook sharing is complex, often requires their SDK or a share dialog.
                     // A simple text share link is not officially supported or reliable for native app.
                     // This will likely open their web share dialog.
                     shareUrl = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent('https://adabalap.github.io/Gita/')}&quote=${url}`;
                     break;
                 case 'twitter':
                     // Twitter Web Intent URL
                     shareUrl = `https://twitter.com/intent/tweet?text=${url}`;
                     break;
                 case 'generic':
                     // Fallback for generic share - copy to clipboard
                     copyToClipboard(text);
                     showMessage('శ్లోకం కాపీ చేయబడింది! మీరు ఇప్పుడు దీన్ని ఎక్కడైనా పంచుకోవచ్చు.', 'info'); // Verse copied! You can now share it anywhere.
                     return; // Don't open a new window for copy
             }

             if (shareUrl) {
                 window.open(shareUrl, '_blank');
             } else if (platform !== 'generic') {
                 // If a specific platform link wasn't generated, suggest copying
                 copyToClipboard(text);
                 showMessage('ఈ ప్లాట్‌ఫారమ్‌కు నేరుగా భాగస్వామ్యం చేయడం సాధ్యం కాలేదు. శ్లోకం కాపీ చేయబడింది!', 'info'); // Direct sharing to this platform failed. Verse copied!
             }
        }

        // Function to copy text to clipboard
        function copyToClipboard(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            // Styling to make the textarea invisible but selectable
            textarea.style.position = 'fixed';
            textarea.style.left = '-9999px';
            textarea.style.top = '0';
            document.body.appendChild(textarea);
            textarea.focus();
            textarea.select();
            try {
                document.execCommand('copy');
            } catch (err) {
                console.error('Unable to copy to clipboard', err);
            }
            document.body.removeChild(textarea);
        }


        // --- PWA Service Worker Registration ---
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Register Service Worker with scope for /Gita/ subfolder
                navigator.serviceWorker.register('/Gita/service-worker.js', { scope: '/Gita/' })
                    .then(registration => {
                        console.log('Service Worker registered:', registration);
                    })
                    .catch(error => {
                        console.error('Service Worker registration failed:', error);
                        console.error('Ensure service-worker.js is at the root of your /Gita/ subfolder on GitHub Pages.');
                        console.error(error);
                    });
            });
        }

        // --- Offline Data Display from Cache ---
        // This is handled implicitly by the fetchVerse function.
        // When offline, the fetch() request will fail, but the Service Worker
        // might intercept it and serve from the cache if the API response was cached.
        // Additionally, the localStorage cache check at the beginning of fetchVerse
        // allows displaying previously viewed verses even if the Service Worker cache is missed
        // for the API request itself (though the Service Worker should ideally cache API responses too).
        // To explicitly handle offline *initial* load for a specific verse (e.g., last viewed),
        // you could add logic here on window.load to check localStorage and display if available.

        window.addEventListener('online', () => {
            console.log('App is online.');
            // Optional: Re-fetch current verse or sync data if needed
        });

        window.addEventListener('offline', () => {
            console.log('App is offline.');
            // Optional: Display an offline message to the user
            // The fetchVerse function now handles showing a specific offline message
            // if the requested verse is in the cache.
        });

        // --- App Version Display ---
        function displayAppVersion() {
            // This is where you will get the version from your build process.
            // For GitHub Pages releases, you can use a GitHub Action to:
            // 1. Get the release tag (e.g., from GITHUB_REF environment variable like 'refs/tags/v1.0.0').
            // 2. Extract the version number (e.g., 'v1.0.0').
            // 3. Inject this version number into your index.html or a separate JS file.
            //    A simple way is to replace a placeholder string in index.html during the build/deploy step.
            //    Example GitHub Action step (using sed, requires bash):
            //    - name: Inject App Version
            //      run: sed -i "s|__APP_VERSION__|${{ github.ref_name }}|g" index.html
            //      env:
            //        GITHUB_REF_NAME: ${{ github.ref_name }}

            // In your HTML, you would have a placeholder like:
            // <div id="appVersionDisplay">Version: __APP_VERSION__</div>

            // And here in the script, you would read that placeholder text.
            // If you use the sed example above, the HTML will be updated directly.
            // If you set a global JS variable in the build, you would read it here:
            // const appVersion = window.APP_VERSION || 'N/A';
            // appVersionDisplay.textContent = `Version: ${appVersion}`;

            // For now, let's use a simple placeholder text that you can manually update
            // or that your GitHub Action will replace.
            const versionPlaceholder = appVersionDisplay.textContent || '';
            if (versionPlaceholder.includes('__APP_VERSION__')) {
                // If the placeholder is still there, set a default or instruction
                appVersionDisplay.textContent = 'App Version: (Build process needs to inject version)';
            } else if (versionPlaceholder.trim() === '') {
                 // If the div is empty, set a default or instruction
                 appVersionDisplay.textContent = 'App Version: (Version placeholder missing)';
            } else {
                 // If the placeholder was replaced by the build process, the text is already correct.
                 // You might want to prepend "App Version: " if your build process only injects the number.
                 if (!versionPlaceholder.startsWith('App Version:')) {
                      appVersionDisplay.textContent = `App Version: ${versionPlaceholder.trim()}`;
                 }
            }

            // Example of how you might set a global variable in your build process (e.g., in a separate JS file loaded before this script):
            // window.APP_VERSION = "${{ github.ref_name }}"; // This line would be injected by GitHub Actions

            // If using the global variable method:
            // const appVersion = window.APP_VERSION || 'N/A';
            // appVersionDisplay.textContent = `App Version: ${appVersion}`;

             // Let's add a default text if no version is injected
             if (appVersionDisplay.textContent.includes('__APP_VERSION__') || appVersionDisplay.textContent.trim() === '' || appVersionDisplay.textContent.includes('(Version placeholder missing)')) {
                  appVersionDisplay.textContent = `App Version: Development Build`; // Default text
             }
        }


    </script>
</body>
</html>
